## 데이터베이스와 DBMS
데이터베이스: 일정한 규칙 혹은 규약을 통해 구조화 되어 저장된 **데이터의 모음**

DBMS(DataBase Management System): 데이터베이스에 데이터를 삽입하거나 저장된 데이터를 수정, 조회할 수 있는 시스템.

## 엔티티(Entity)
엔티티는 여러 속성을 가진 명사를 의미한다. 엔티티는 약한 엔티티와 강한 엔티티로 나뉜다.

- 약한 엔티티: 혼자 존재할 수 없으며 다른 엔티티에 종속적인 엔티티
- 강한 엔티티: 혼자 존재할 수 있는 엔티티

예를 들어 건물은 강한 엔티티이고 방은 건물에 종속되므로 약한 엔티티이다. 약한 엔티티는 소유자(종속하고 있는 엔티티)의 Primary Key로 식별할 수 있다. 

만약 약한 엔티티 사이에도 구분이 필요하다면 Partial Key로 구분한다. 예를 들어 직원의 부양가족이 여러 명인 경우 Partial Key를 도입하여 부양가족을 구분한다. 소유자의 Primary Key와 Partial Key를 엮어서 약한 엔티티를 완벽하게 구분할 수 있다.

### ⭐ 질문 대비
Q1. 약한 엔티티가 약한 엔티티에 의존할 수 있나요? <br>
A1. 약한 엔티티는 약한 엔티티에 의존할 수 있습니다. 단 이 경우 Primary Key와 Partial Key를 모두 상속받아야 유일한 식별자를 생성할 수 있습니다. 또한 약한 엔티티 체인이 길어진다면 JOIN 비용이 증가하고 PK가 복잡해지기 때문에 이 경우 약한 엔티티를 강한 엔티티로 승격시키는 방법을 고려해봐야 합니다.

Q1-1. 약한 엔티티를 강한 엔티티로 승격하는 예시 하나만 말해보세요.<br>
A1-1. 약한 엔티티의 대표적인 예시는 '다대다 관계에서 만든 중간 테이블에 PK가 없는 경우'입니다. 이 경우 PK를 부여하고 다대다 관계에 필요한 정보를 FK로 설정하면 약한 엔티티를 강한 엔티티로 승격시킬 수 있습니다. 예를 들어 OrderItem 엔티티가 order_id와 item_id를 조합하여 PK를 구성했다면 약한 엔티티이지만, order_item_id를 PK로 두고 order_id, item_id를 FK로 둔다면 이는 강한 엔티티라고 할 수 있습니다.

Q2. 약한 엔티티의 장단점 설명해주세요.<br>
A2. 약한 엔티티는 실세계의 종속 관계를 정확히 모델링할 때 유용합니다. 또한 기본키를 따로 생성하지 않기 때문에 저장 공간을 절약할 수 있습니다. 하지만 Primary Key + Partial Key로 이루어진 복합키를 사용해야 하기 때문에 관리가 복잡하고 복합키가 길어질수록 성능 이슈가 발생할 수 있습니다.

참고
- https://www.quora.com/Can-a-weak-entity-be-dependent-on-another-weak-entity-in-ER-Model
- Claude

## 릴레이션(Relation)
릴레이션은 데이터베이스에 정보를 구분하여 저장하는 단위이다. 엔티티에 관련된 데이터를 하나의 릴레이션에 저장한다. 관계형 데이터베이스에서는 '테이블'이라고 부르고 NoSQL에서는 '컬렉션'이라고 부른다.

### Record와 Document
관계형 데이터베이스와 NoSQL에서 릴레이션의 구조는 아래와 같다.
- 관계형 데이터베이스: 데이터베이스 - 테이블 - Record
- NoSQL: 데이터베이스 - 컬렉션 - Document

## 속성
릴레이션에서 관리하는 구체적이며 **고유한** 이름을 갖는 정보

## 도메인
각 속성들이 가질 수 있는 값의 집합. 성별이라는 속성의 도메인은 {남, 여}이다.

## 필드와 레코드
아래는 Member 테이블이다.

회원 엔티티는 ID, 이름, 휴대폰 번호의 속성을 가지고 있고 관련 데이터를 저장하는 Member 테이블은 id, name, phone_number 필드가 존재하고 3개의 레코드가 저장되어 있다.
![4.1.1](<img/4.1.1.png>)

## 필드 타입
MySQL의 필드 타입 기준이다.

### 숫자 타입
| 타입 | 크기 | 부호 있음 범위 | 부호 없음 범위 |
|------|:----:|:-------------:|:-------------:|
| TINYINT | 1바이트 | -128 ~ 127 | 0 ~ 255 |
| SMALLINT | 2바이트 | -32,768 ~ 32,767 | 0 ~ 65,535 |
| MEDIUMINT | 3바이트 | -8,388,608 ~ 8,388,607 | 0 ~ 16,777,215 |
| INT | 4바이트 | -2,147,483,648 ~ 2,147,483,647 | 0 ~ 4,294,967,295 |
| BIGINT | 8바이트 | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 0 ~ 18,446,744,073,709,551,615 |

### 날짜 타입
- DATE: 날짜 부분은 있지만 시간 부분은 없음. 1000-01-01 ~ 9999-12-31 표현 가능. **3바이트**
- DATETIME: 날짜 및 시간 부분 모두 표현. 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 표현 가능. **8바이트**
- TIMESTAMP: 날짜 및 시간 부분 모두 표현. 1970-01-01 00:00:00 ~ 2038-01-19 03:14:07 표현 가능. **4바이트**

### 문자 타입
- **CHAR와 VARCHAR: CHAR는 고정 길이, VARCHAR는 가변 길이 데이터를 저장하기에 적합하다.** CHAR(30)에 10byte를 저장할 경우 할당되는 용량은 30byte, VARCHAR(30)에 10byte를 저장할 경우 할당되는 용량은 10byte + 길이 저장용 1byte이다. CHAR는 0-255byte, VARCHAR는 0-65,535byte를 저장할 수 있다.
- TEXT와 BLOB: 큰 데이터를 저장할 때 사용한다. 
  - TEXT는 큰 문자 데이터를 저장할 때 보통 사용한다. 
  - BLOB은 이미지, 동영상등 큰 데이터에 사용한다. 그러나 DB에 직접 이미지나 동영상을 저장하지 않고 S3와 같은 서버에 파일을 올리는 게 일반적이다.
- ENUM과 SET: ENUM과 SET은 모두 문자열을 열거하는 타입이다.
  - ENUM은 ENUM('A', 'B', 'C') 형태로 사용되며 이 중 하나만 삽입할 수 있다. 잘못된 값을 삽입하면 빈 문자열이 대신 삽입된다. ENUM을 사용하면 'A', 'B', 'C'가 각각 0, 1, 2 등으로 매핑되어 **메모리를 적게 사용할 수 있다**. ENUM에는 최대 65,535RODML 요소를 넣을 수 있다.

### ⭐ 질문 대비

Q1. TEXT에 문자를 저장할 때 글자수 제한을 걸고 싶다면 어떻게 해결하시는 편인가요?<br>
A1. 보통 애플리케이션 레벨에서 글자수를 검증합니다. 만약 VARCHAR에 담을 수 있는 길이의 문자열이라면 데이터 타입을 VARCHAR로 선언하는 게 좋을 것 같습니다.

Q2. DB에 이미지나 동영상을 직접 저장하는 것을 지양해야 하는 이유를 알려주세요.<br>
A2. 다음과 같은 이유가 있습니다.
1. 멀티 미디어 데이터는 용량이 크기 때문에 데이터베이스에 로드할 때 많은 메모리가 소모되고 네트워크 부하가 증가하여 시스템 전체적인 속도가 감소합니다.
2. DB 샤딩이나 읽기 복제본 생성 시 시간이 오래 걸리고 백업 파일의 크기가 커져서 백업 시간도 길어집니다.
3. 클라우드 사용 시 일반적으로 DB 저장소는 파일 저장소보다 비용이 크기 때문에 과금이 많이 발생할 수 있습니다.

## 키
키는 테이블에 저장된 레코드를 구분하는 역할을 하며, 테이블의 인덱스와 테이블 간의 관계를 설명할 때도 사용된다.

![4.1.2](<img/4.1.2.png>)

- 유일성: 중복되는 값이 없음
- 최소성: 키를 형성할 수 있는 최소한의 필드만 포함

### 기본키
PK(Primary Key)라고 많이 부르며 유일성과 최소성을 모두 만족한다. 기본키는 **자연키** 또는 **인조키** 중에 골라서 설정한다.

- 자연키: 삽입되는 데이터에서 자연적으로 뽑을 수 있는 기본키를 의미한다. 대표적인 예시로 주민등록번호가 있다. 하지만 자연키는 언젠가는 변하는 속성을 가진다.
- 인조키: 인위적으로 부여하는 키를 의미한다. MySQL의 경우 auto increment, Oracle의 경우 sequence로 설정할 수 있다.

보통 기본키는 인조키로 설정한다.

### 외래키
FK(Foreing Key)라고 많이 부르며 다른 테이블의 기본키를 그대로 참조하는 값이다. 관계를 식별할 때 사용한다. 외래키는 중복될 수 있다.

### 후보키
후보키(Candidate Key)는 기본키가 될 수 있는 후보들이며 유일성과 최소성을 모두 만족한다.

### 대체키
기본키가 아닌 후보키를 대체키(Alternate Key)라고 한다.

### 슈퍼키
유일성만 갖춘 키를 슈퍼키(Super Key)라고 한다.

